## 指针

1. 在32为操作系统下，任何指针都占4个字节空间。64位是8个字节

2. 空指针与野指针

空指针：指针变量指向内存中编号为0的空间

    用途：初始化指针变量   
    空指针是不可进行访问的

野指针：指针变量指向非法的内存空间

空指针和野指针都不是用户申请的空间，不能访问

3. const修饰指针

const修饰指针有三种情况：

* 修饰指针 --> 常量指针
    ```
    int a;
    const int* p = &a;
    ```
  * 指针的指向可以修改，但指针引用的值不可修改
* 修饰常量 --> 指针常量：
    ```
    int a;
    int* const p = &a;
    ```
  * 指针的指向不可以修改，但指针引用的值可修改
* 既修饰指针又修饰常量
    ```
    int a;
    const int* const p = &a;
    ```
  * 指针的指向和指针引用的值都不可修改

## 内存分区模型

对于不同区域存放的数据，赋予不同的声明周期，使编程更灵活

* 代码区：存放函数体的二进制代码，由操作系统管理
* 全局区：存放全局变量和静态变量以及常量
* 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
* 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

编译后生成的可执行程序，被分为两个区域：

* **代码区**

  存放CPU执行的机器指令

  代码区是``共享``的，目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

  代码区是``只读``的，原因是防治程序意外修改其中的数据
  
* **全局区**

  存放``全局变量``、``全局常量``和``静态变量``

  该区域的数据在程序结束后由操作系统释放

* **栈区**

  由编译器自动分配释放  

  存放函数的参数值，局部变量等

  注： 不要返回``局部变量的地址``，因为其引用的值在函数执行结束后自动释放

* **堆区**
  
  有程序员分配和释放，程序结束时由操作系统回收

  在C++中主要利用new在堆区开辟内存，用delete回收内存

  * new开辟空间
    ```cpp
    new 数据类型; //返回值为该数据类型的指针
    int* num = new int(10); //创建值为10的整型数
    int* array = new int[10]; //创建长度为10的整型数组
    ```
  * delete释放堆区空间
    ```cpp
    delete 变量名; //释放变量
    delete num; //释放变量
    delete[] array; //释放数组需要加[]
    ```

## 引用

  作用：给变量起别名

  语法：数据类型 &别名= 原名

  ```cpp
  int a = 10;
  int &b = a;
  ```
  注意事项：
  * 引用必须在创建时就初始化
  * 引用一旦初始化后就不可更改

  引用做函数参数：实现形参修饰实参，调用前后实参值发生改变
  ```cpp
  void swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
  }

  int main(){
    int a = 10;
    int b = 20;
    swap(a, b);
  }
  ```

  函数的调用可做为等号的左值：

    ```cpp

    int& test1(){
      static int a = 10; //静态变量存在全局区
      return a;
    }

    int main(){
        int &b = test1(); //b = 10
        test1() = 1000;  //b的值将会为1000；
        /*函数返回静态变量的引用，该变量不会随函数运行
        结束而被释放，test1()=1000即：将函数中定义的
        静态变量的值更新为1000，而b为该静态变量的引
        用，故b的值也得以更新 */
        return 0;
    }
    ```

  引用的本质：指针常量

  定义一个引用
  ```cpp
  int& ref = a;
  ```
  该定义将自动转换为:
  ```cpp
  int* const ref = &a;
  ```

  常量引用：
  
  ```cpp
  const int& a
  ```
  
  通常用来修饰形参，以防止误操作修改实参。
  
  相对于传值来说，传常量引用可省内存，因为传值是复制实参，而传引用只是申请了一块4字节的指针空间。

## 函数提高

* 函数的默认参数

  语法：形参 = 默认值

  * 如果在某个位置已经有了默认参数，则从这个位置往右的所有参数也都必须有默认参。即，默认形参必须在函数参数列表的结尾。
  ```cpp
  int func(int a, int b = 20, int c = 30){
    ...
    ...
  }
  fun(10); //a = 10, b = 20, c = 30
  fun(10, 40); //a = 10, b = 40, c = 30
  ```
  * 对于函数的声明和函数实现，只能在一处给参数赋默认值。即，默认参数不能重定义。

* 占位参数

  ```cpp
  void func(int a, int){
  //返回值类型 函数名（数据类型）
  ...
  }
  func(10, 10);

  void func(int a, int = 10){
    //占位参数也可以有默认值
  }
  func(10);
  ```

## 类
* 函数的拷贝构造函数
  ```cpp
  ClassName(const ClassName& p){
    xxx = p.xxx;
    xxx = p.xxx;
    //将传入的类的所有属性拷贝到该类自身
  }
  ```
* 调用构造函数：
  * 括号法：
  ```cpp
  ClassName p1; //无参构造方法
  ClassName p2(10); //有参构造方法
  ClassName p3(p2); //拷贝构造方法
  ```
  调用无参构造函数时，不能用() ，编译器将会把``ClassName p1()``认为是函数的声明

  * 显式法：
  ```cpp
  ClassName p1; //无参构造
  ClassName p2 = ClassName(10); //有参构造
  ClassName p3 = ClassName(p2); //拷贝构造
  //ClassName(10); 是一个匿名对象。当前行执行结束后系统立即回收该匿名对象
  ```
  不要利用拷贝构造函数初始化匿名对象，编译器会认为ClassName(p3) == ClassName p3;，把它当做对象的声明


  * 隐式转换法
  ```cpp
  ClassName p4 = 10;  //相当于ClassName p4 = ClassName(10);
  ClassName p5 = p4;  //拷贝构造，相当于ClassName p5 = ClassName(p4);
  ```

  * 拷贝构造函数的调用时机
    * 使用一个创建完毕的对象来初始化一个新的对象
    * 以值传递的方式给函数参数传值。
      ```cpp
      void func(ClassName p1){
        ....
      }
      ``` 
      即：函数实参在传递给形参时候会调用拷贝构造函数，复制实参一份传入函数
    * 以值方式返回局部对象
      ```cpp
      ClassName func(){
        ClassName p1;
        return p1;
      } 
      ```
      即函数返回时，将调用拷贝构造函数，拷贝一个新的对象返回。
* 构造函数的调用规则
  
  默认情况下，C++编译器至少给一个类添加三个函数：

  * 默认构造函数(无参，函数体为空)
  * 有参构造函数(有参，函数体为空)
  * 默认拷贝构造函数(对所有属性，进行值拷贝)

  构造函数的定义规则如下：

  * 如果用户定义了有参构造函数，C++将不再提供无参构造函数，但会提供默认拷贝构造函数
  * 如果用户定义拷贝构造函数，C++将不会再提供其他构造函数

* 深拷贝与浅拷贝
  * 浅拷贝: 简单的赋值拷贝操作
  * 深拷贝: 在堆区重新申请空间，进行拷贝操作
  * 浅拷贝带来的问题：堆区的指针内存重复释放
 
* 初始化列表给类属性赋初值
```cpp
class ClassName{
  int a;
  int b;
  int c;
  ClassName(): a(10), b(20), c(30)
  {
      //无参构造函数

      //在构造函数的形参列表后加冒号
      //后接属性名(属性值)，多个元素之间用逗号分隔
  }
  ClassName(int a, int b, int c): a(a), b(b), c(c)
  {
      //有参构造函数
  }
};
ClassName p1;  //p1初始状态的a = 10, b = 20, c = 30
ClassName p2(10, 20, 30); 

```
* 静态成员(static修饰)
  
  静态成员变量

  * 所有对象共享一份数据
  * 在编译阶段分配内存
  * 类内声明，类外初始化
    ```cpp
    class ClassName{
      static int a;
    };
    int ClassName::a = 0;
    ``` 

  静态成员函数

  * 所有对象共享同一个函数
  * 静态成员函数只能访问静态成员变量

  静态成员的访问：

  1. 通过对象名访问
  ```cpp
  ClassName p;
  p.a; //静态成员变量
  p.fun();  //静态成员函数
  ```
  2. 通过类名访问
  ```cpp
  ClassName.a; //静态成员变量
  ClassName::fun();  //静态成员函数
  ```

* 成员的存储

  成员变量和成员函数是分开存储的。

  * 只有类的非成员变量属于类的对象
  * 类的非静态成员变量和类成员函数都不属于类的对象
  * 空对象(即一个空类的对象)占用1字节内存空间。为了区分空对象占用内存的位置

* this指针

  this指针为``指针常量``。指向被调用的成员函数所属的对象

  ``ClassName * const this``
  
  *this作成员函数的返回值，返回该对象自身的引用

  ```cpp
  class ClassName{
  public:
    int a;
    ClassName& add_a(){
      this->a += 10;
      return *this;
    }
  };
  ClassName entity;
  entity.a = 10;
  entity.add_a().add_a().add_a().add_a();
  //此时，eneity.a = 50, 加了四次10
  ```

* const修饰成员函数(常函数)
  
  常函数：
  
  * 成员函数后加const，则成该函数为常函数
    ```cpp
    void func() const{
      ...
    } 
    ```
    此const将this指针修饰为``const ClassName * const this

  * 常函数内不可修改成员属性, 因为this指向的值不可修改
  * 成员属性声明时加关键是mutable后，在常函数和常对象中依然可以被修改
  
  常对象：
  * 声明前加const修饰该对象为常对象
    ```cpp
    const ClassName p;
    ``` 
  * 常对象的属性值不允许被修改
  * 常对象只能调用常函数

* 友元

  允许一个函数或者类访问另一个类的私有成员

  * 全局函数作友元
    ```cpp
    class ClassName{
      friend void fun(); 
      ...
    };
    ```
    将全局函数的声明前加上friend放在类定义中
  * 类作友元
    ```cpp
    class ClassName{
      friend class FriendClass;
      ...
    }
    ```
    将友元类的声明前加上friend放在类定义中
  * 成员函数作友元
    ```cpp
    class ClassName{
      friend void FriendClass::friend_func();
      ...
    }
    ```
    将类的成员函数声明放在另一个类的定义中

## 运算符重载
  

